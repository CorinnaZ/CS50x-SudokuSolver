# CS50x-SudokuSolver
## Video Demo:  <URL HERE>

## Overview:
This repository was created as my final project for the 2022's edition of CS50x. For the project, I have written a GUI program in C# (WPF) that can display and solve sudokus (see: [Wikipedia](https://en.wikipedia.org/wiki/Sudoku)). It was developed in Visual Studio 2022 (Community Edition). I have chosen C# and WPF as a language because I need to learn it for my job.

The Visual Studio solution contains multiple projects, as I found it easier to divide the projects according to their usecase. To understand the structure of the code, I will explain the pattern I used first. I tried to employ the MVVM Pattern (see: [Wikipedia MVVM](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel)), in which you separate the GUI and its code-behind from the actual logic. Therefore, in the startup project "finalProject", I have a "MainWindow.xaml" which displays the GUI, the code-behind "MainWindow.xaml.cs", which actually generates most of the objects seen in the GUI and manages the bindings, and my model "SudokuWrapper.cs", which controls the logical calls to functions when buttons are pressed or values are changed in the GUI. The class `SudokuWrapper` contains relay commands for controlling the GUI and reacting to the user's inputs, and functions that start the solving process, check the current solution (in case the user wants to solve the sudoku manually), functions for loading and saving sudokus to file and functions that handle the logging. On the topic of logging: a logpath is saved in the `%appdata%` folder of the user, which can be modified within the GUI or directly in the file.

The two projects "Sudoku" and "Servants" are independent from the other projects, as they offer key functionality. The project "Servants" only contains the file "DebugServant.cs", which I used to bundle logging functions. The class `DebugServant` provides functions for creating and filling a log, which I found very useful for debugging purposes. The project "Sudoku" contains the class `Sudoku` with its internal 2D grid for the sudoku data and some functions for data reading and writing, such as `GetRow`, `GetColumn`, `GetSquare`, getter and setter functions for single elements and functions such as `IsValidSudoku` that check if a sudoku is valid or has multiple of the same numbers in a row, column or square. Corresponding to the "Sudoku" project, there is a "SudokuTest" project which is not used for normal operation of the code. This is the place where I tested the functions that the class provides.

The remaining four projects belong together, as they provide the logic to solve sudokus. First of all, the "SudokuSolver" project contains the abstract `Solver` class which includes basic functions that every implementation of a sudoku solver would need. This includes internal variables such as a datastructure for the sudoku, a logpath and a `DebugServant`, multiple constructors and utility functions such as functions that check if rows, columns and squares of the current solution are valid, functions that search for the first empty cell in the sudoku and, of course, the abstract function `SolveSudoku` that differs from implementation to implementation. The project "SudokuSolverTest" was created to test the functions that the solvers provided in a command line environment. I like to differ between tests of the whole program including the GUI and tests of the logical funtions in the background, as a command line test program eliminates the error source of failed bindings or mistakes in the GUI programming. 

The first sudoku solving algorithm I implemented is the "BruteForceSolver", which only overrides the `SolveSudoku` function from the base class but offers and needs no additional logic. First, it tries to find any unoccupied cell in the sudoku. Empty cells were marked with a 0, as this number does not occur in a solved sudoku. If the program does not find an empty cell, it concludes that the sudoku is solved. If it finds any empty cell, the program cycles through all possible numbers `(1...9)` and fills the cell with the first number that would be valid under the current circumstances. Then it continues recursively and searches for the next empty cell. Of course, just because a number is valid in the beginning stages of the solving algorithm, it does not mean that the number is actually correct. If, at any point, the sudoku cannot be solved, the algorithm backtracks to the last decision and tries a different valid number for that cell, and so on. As the name suggests, the program uses brute force to find a solution to a sudoku. For easy sudokus, this algorithm still takes multiple seconds and is not the way a human would intuitively solve such a puzzle. Therefore, I have solved a few sudokus and documented the steps I took to solve them in order to formulate a more elegant algorithm.

This leads us to the second algorithm, which I called "ComplexSolver". Similar to the brute force algorithm, it inherits its variables and functions from the `Solver` base class, but expands the functional range. To solve a sudoku, it applies the following steps: first of all, the algorithm searches for and writes all single missing entries in rows, columns or squares, as these are the easiest cells to fill. Second, the program constructs a 2D array of integer lists called `possibleValues`. This 2D array has the same size of the sudoku and contains a list of integers for each cell. While cycling over the cells of the sudoku, each cell's list is filled with all numbers that could, right now, possibly be in this cell. At this point, the brute force algorithm would just insert the first of these numbers and continue, but with this algorithm I collect all possible numbers for each cell first. Then, in a loop, I check the `possibleValues` for cells where only one possible number is noted. This number is the only candidate for that specific cell, so I put the number in the actual sudoku cell and delete it from the other `possibleValue`-cells in the same row, column and square. Then the algorithm checks again if there are any rows, columns or squares which are only missing one number, and, if so, completes them, and continues the loop anew, until the sudoku is solved. This algorithm is much faster, as it does not have to backtrack in case of wrong decisions, and takes less than a second to solve easy sudokus.

## Documentation:
All functions are documented in the code, from this documentation, a doxygen documentation was created. It can be accessed in the folder "Documentation/html".

If you have any questions, do not hesitate to contact me.

Happy coding!
CorinnaZ
